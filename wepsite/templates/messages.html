{% extends "base.html" %}

{% block title %}Messages - {{ pet.name if pet and not pet.is_deleted else 'Archived Pet' }}{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/messages.css') }}">
{% endblock %}

{% block content %}
<!-- Error/Success Toast Messages -->
<div id="errorToast" class="error-toast"></div>
<div id="successToast" class="success-toast"></div>

<!-- Connection Status Indicator -->
<div id="connectionStatus" class="connection-status status-disconnected" style="display: none;">
    üî¥ Disconnected
</div>

<!-- Hero Section -->
<section class="messages-hero">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-lg-8">
                <div class="hero-content">
                    <h1 class="hero-title">Chat Messages üí¨</h1>
                    <p class="hero-subtitle">Connect with potential adopters and pet owners</p>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Main Messages Section -->
<section class="main-section">
    <div class="container">
        <!-- Floating decorative elements -->
        <div class="floating-element">üí¨</div>
        <div class="floating-element">üê±</div>
        <div class="floating-element">‚ù§Ô∏è</div>
        
        <div class="row justify-content-center">
            <div class="col-md-10 col-lg-8">
                <div class="chat-container">
                    <!-- Chat Header -->
                    <div class="chat-header">
                        <div class="pet-info">
                            <div class="pet-details">
                                <h5 class="pet-name">
                                    {% if application.pet and not application.pet.is_deleted %}
                                        <a href="{{ url_for('views.pet_detail', pet_id=application.pet.id) }}" class="pet-link">
                                            üêæ {{ application.pet.name }} ({{ application.pet.breed }})
                                        </a>
                                        <small class="poster-info">
                                            Posted by {{ application.pet.poster.first_name }}
                                        </small>
                                    {% else %}
                                        <span class="archived-pet">üìÅ Archived Pet Conversation</span>
                                    {% endif %}
                                </h5>
                                {% if application.pet and application.pet.is_deleted %}
                                    <small class="unavailable-notice">‚ö†Ô∏è This pet is no longer available</small>
                                {% endif %}
                            </div>
                            <div class="status-badge">
                                <span class="badge status-{{ application.status }}">
                                    {% if application.status == 'approved' %}‚úÖ{% endif %}
                                    {% if application.status == 'pending' %}‚è≥{% endif %}
                                    {% if application.status == 'rejected' %}‚ùå{% endif %}
                                    {% if application.status == 'archived' %}üìÅ{% endif %}
                                    {{ application.status|title }}
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Application Details (Admin Only) -->
                    {% if current_user.is_admin and application.answers %}
                    <div class="application-details">
                        <h6 class="details-title">üìã Application Details</h6>
                        <div class="details-content">
                            {% set answers = application.answers|from_json %}
                            <div class="details-grid">
                                {% for question, answer in answers.items() %}
                                    <div class="detail-item">
                                        <strong>{{ question|replace('_', ' ')|title }}:</strong>
                                        <span>{{ answer }}</span>
                                    </div>
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                    {% endif %}

                    <!-- Message Count -->
                    <div class="message-count" id="messageCount">
                        {{ messages|length }} message{{ 's' if messages|length != 1 else '' }}
                    </div>

                    <!-- Messages Container -->
                    <div class="messages-container" id="messagesContainer">
                        {% for msg in messages %}
                            <div class="message-wrapper" data-message-id="{{ msg.id }}" data-sequence="{{ msg.sequence_number }}" data-client-id="{{ msg.client_id }}">
                                <div class="message {{ 'message-sent' if msg.sender_id == current_user.id else 'message-received' }}">
                                    <div class="message-bubble">
                                        <div class="message-header">
                                            <span class="sender-name">{{ msg.sender.first_name }}</span>
                                            <span class="message-time">{{ msg.timestamp.strftime('%b %d, %I:%M %p') }}</span>
                                            {% if msg.sender_id == current_user.id %}
                                                <span class="read-status">
                                                    {% if msg.is_read %}
                                                        <i class="read-icon read" title="Read">‚úì‚úì</i>
                                                    {% else %}
                                                        <i class="read-icon delivered" title="Delivered">‚úì</i>
                                                    {% endif %}
                                                </span>
                                            {% endif %}
                                        </div>
                                        <p class="message-content">{{ msg.content }}</p>
                                    </div>
                                </div>
                            </div>
                        {% endfor %}
                    </div>

                    <!-- Typing Indicator -->
                    <div class="typing-indicator" id="typingIndicator">
                        Someone is typing...
                    </div>

                    <!-- Message Input -->
                    <div class="chat-footer">
                        {% if application.status == 'archived' or (application.pet and application.pet.is_deleted) %}
                            <div class="archived-notice">
                                <i class="archive-icon">üìÅ</i>
                                <span>This application is archived and cannot be modified.</span>
                            </div>
                        {% else %}
                            <form id="message-form" method="POST" action="{{ url_for('views.messages', application_id=application.id) }}" class="message-form">
                                <input type="hidden" name="form_id" value="{{ form_id }}">
                                <div class="input-wrapper">
                                    <input type="text" 
                                           name="message" 
                                           class="message-input" 
                                           placeholder="Type your message..." 
                                           maxlength="1000"
                                           required>
                                    <button type="submit" class="send-btn" id="sendBtn">
                                        <span class="btn-text">Send</span>
                                        <span class="btn-icon">üì§</span>
                                    </button>
                                </div>
                                
                                <!-- Character counter -->
                                <div class="char-counter">
                                    <span id="charCount">0</span>/1000
                                </div>

                                {% if current_user.is_admin and application.pet.posted_by == current_user.id and application.status == 'pending' %}
                                <div class="quick-replies">
                                    <button type="button" class="quick-reply-btn approve-btn" data-reply="approved">
                                        ‚úÖ Approve Application
                                    </button>
                                    <button type="button" class="quick-reply-btn info-btn" data-reply="questions">
                                        ‚ùì Request More Info
                                    </button>
                                    <button type="button" class="quick-reply-btn reject-btn" data-reply="rejected">
                                        ‚ùå Need More Details
                                    </button>
                                </div>
                                {% endif %}
                            </form>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block scripts %}
<script>
// Enhanced messaging with race condition prevention
document.addEventListener('DOMContentLoaded', function() {
    const messageContainer = document.getElementById('messagesContainer');
    const messageInput = document.querySelector('input[name="message"]');
    const sendBtn = document.getElementById('sendBtn');
    const charCount = document.getElementById('charCount');
    const messageCount = document.getElementById('messageCount');
    const connectionStatus = document.getElementById('connectionStatus');
    
    let messageCounter = {{ messages|length }};
    let currentSequence = {{ messages[-1].sequence_number if messages else 0 }};
    let pendingMessages = new Map(); // Track messages being sent
    let usePolling = false;
    let pollingInterval;
    
    // Generate client ID for messages
    function generateClientId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    // Get last sequence number from DOM
    function getLastSequence() {
        const lastMessage = messageContainer.querySelector('.message-wrapper:last-child');
        return lastMessage ? parseInt(lastMessage.dataset.sequence) || 0 : 0;
    }

    // Add message to DOM
    function addMessageToDOM(messageData, status = 'sent') {
        const existingMessage = messageContainer.querySelector(`[data-client-id="${messageData.client_id}"]`);
        if (existingMessage) {
            // Update existing message
            updateMessageStatus(existingMessage, status, messageData);
            return;
        }

        const userId = {{ current_user.id }};
        const messageClass = messageData.sender_id === userId ? 'message-sent' : 'message-received';
        const statusClass = status === 'sending' ? 'message-sending' : '';
        
        const messageHtml = `
            <div class="message-wrapper ${statusClass}" 
                 data-message-id="${messageData.id || 'temp'}" 
                 data-sequence="${messageData.sequence_number || currentSequence + 1}"
                 data-client-id="${messageData.client_id}">
                <div class="message ${messageClass}">
                    <div class="message-bubble">
                        <div class="message-header">
                            <span class="sender-name">${messageData.sender}</span>
                            <span class="message-time">${messageData.timestamp}</span>
                            ${messageData.sender_id === userId ? `
                                <span class="read-status">
                                    <i class="read-icon ${status === 'sending' ? 'sending' : 'delivered'}" 
                                       title="${status === 'sending' ? 'Sending...' : 'Delivered'}">
                                       ${status === 'sending' ? '‚è≥' : '‚úì'}
                                    </i>
                                </span>` : ''}
                        </div>
                        <p class="message-content">${messageData.content}</p>
                        ${status === 'failed' ? '<div class="message-error">‚ùå Failed to send</div>' : ''}
                    </div>
                </div>
            </div>
        `;
        
        messageContainer.insertAdjacentHTML('beforeend', messageHtml);
        scrollToBottom();
        
        // Update counter
        messageCounter++;
        updateMessageCount();
        
        // Update sequence
        if (messageData.sequence_number) {
            currentSequence = Math.max(currentSequence, messageData.sequence_number);
        }
    }

    // Update message status
    function updateMessageStatus(element, status, messageData = null) {
        const readIcon = element.querySelector('.read-icon');
        const messageError = element.querySelector('.message-error');
        
        // Remove any existing error messages
        if (messageError) messageError.remove();
        
        element.classList.remove('message-sending', 'message-failed');
        
        switch (status) {
            case 'sent':
                element.classList.remove('message-sending');
                if (readIcon) {
                    readIcon.className = 'read-icon delivered';
                    readIcon.textContent = '‚úì';
                    readIcon.title = 'Delivered';
                }
                if (messageData && messageData.id) {
                    element.dataset.messageId = messageData.id;
                }
                break;
            case 'failed':
                element.classList.add('message-failed');
                if (readIcon) {
                    readIcon.className = 'read-icon failed';
                    readIcon.textContent = '‚ùå';
                    readIcon.title = 'Failed';
                }
                element.querySelector('.message-bubble').insertAdjacentHTML('beforeend', 
                    '<div class="message-error">‚ùå Failed to send. Click to retry.</div>');
                break;
            case 'sending':
                element.classList.add('message-sending');
                if (readIcon) {
                    readIcon.className = 'read-icon sending';
                    readIcon.textContent = '‚è≥';
                    readIcon.title = 'Sending...';
                }
                break;
        }
    }

    function updateMessageCount() {
        if (messageCount) {
            messageCount.textContent = `${messageCounter} message${messageCounter !== 1 ? 's' : ''}`;
        }
    }

    function scrollToBottom() {
        messageContainer.scrollTop = messageContainer.scrollHeight;
    }

    function showToast(message, type = 'error') {
        const toast = document.getElementById(type + 'Toast');
        if (toast) {
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 5000);
        }
    }

    function updateConnectionStatus(connected) {
        if (connectionStatus) {
            connectionStatus.style.display = 'block';
            if (connected) {
                connectionStatus.className = 'connection-status status-connected';
                connectionStatus.textContent = 'üü¢ Connected';
                setTimeout(() => {
                    connectionStatus.style.display = 'none';
                }, 3000);
            } else {
                connectionStatus.className = 'connection-status status-disconnected';
                connectionStatus.textContent = 'üî¥ Disconnected - Using fallback';
            }
        }
    }

    // Polling fallback function
    function pollForMessages() {
        if (!usePolling) return;
        
        fetch(window.location.href + '?poll=1')
            .then(res => res.text())
            .then(html => {
                const parser = new DOMParser();
                const newDoc = parser.parseFromString(html, 'text/html');
                const newContainer = newDoc.getElementById('messagesContainer');
                
                if (newContainer) {
                    const newMessages = Array.from(newContainer.querySelectorAll('.message-wrapper'));
                    const existingMessages = Array.from(messageContainer.querySelectorAll('.message-wrapper'));
                    
                    // Only add truly new messages
                    newMessages.forEach(newMsg => {
                        const clientId = newMsg.dataset.clientId;
                        const sequence = parseInt(newMsg.dataset.sequence);
                        
                        if (!messageContainer.querySelector(`[data-client-id="${clientId}"]`) && sequence > currentSequence) {
                            messageContainer.appendChild(newMsg.cloneNode(true));
                            messageCounter++;
                            currentSequence = sequence;
                        }
                    });
                    
                    updateMessageCount();
                    scrollToBottom();
                }
            })
            .catch(err => {
                console.log('Polling failed:', err);
            });
    }

    // Character counter
    if (messageInput && charCount) {
        messageInput.addEventListener('input', function() {
            const count = this.value.length;
            charCount.textContent = count;
            
            if (count > 950) {
                charCount.style.color = '#dc3545';
            } else if (count > 800) {
                charCount.style.color = '#ffc107';
            } else {
                charCount.style.color = '#6c757d';
            }
        });
    }

    // Prevent form resubmission on page refresh
    if (window.history.replaceState && window.location.search) {
        window.history.replaceState(null, null, window.location.pathname);
    }

    // Initial scroll and setup
    scrollToBottom();
    currentSequence = getLastSequence();
    
    // Start polling by default, will be disabled if Socket.IO connects
    usePolling = true;
    pollingInterval = setInterval(pollForMessages, 5000);
});
</script>

<script>
// Enhanced Socket.IO implementation with race condition fixes
let socket;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;

function initializeSocket() {
    try {
        socket = io({
            transports: ['websocket', 'polling'],
            timeout: 5000,
            reconnection: true,
            reconnectionAttempts: maxReconnectAttempts,
            reconnectionDelay: 1000
        });

        const applicationId = '{{ application.id }}';
        const userId = {{ current_user.id }};
        const messageContainer = document.getElementById('messagesContainer');
        const messageInput = document.querySelector('input[name="message"]');
        const sendBtn = document.getElementById('sendBtn');

        // Connection handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            updateConnectionStatus(true);
            reconnectAttempts = 0;
            
            // Disable polling when Socket.IO is working
            usePolling = false;
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            // Join the application room
            socket.emit('join_room', { application_id: applicationId });
            
            // Request synchronization
            socket.emit('sync_messages', {
                application_id: applicationId,
                last_sequence: currentSequence
            });
        });

        socket.on('disconnect', (reason) => {
            console.log('Disconnected:', reason);
            updateConnectionStatus(false);
            
            // Re-enable polling as fallback
            usePolling = true;
            if (!pollingInterval) {
                pollingInterval = setInterval(pollForMessages, 5000);
            }
        });

        socket.on('connect_error', (error) => {
            console.log('Connection error:', error);
            reconnectAttempts++;
            if (reconnectAttempts >= maxReconnectAttempts) {
                showToast('Connection failed. Using fallback mode.', 'error');
                usePolling = true;
                if (!pollingInterval) {
                    pollingInterval = setInterval(pollForMessages, 5000);
                }
            }
        });

        // Synchronization handler
        socket.on('sync_response', (data) => {
            console.log('Sync response:', data);
            
            data.missed_messages.forEach(messageData => {
                addMessageToDOM(messageData, 'sent');
            });
            
            if (data.current_sequence) {
                currentSequence = data.current_sequence;
            }
        });

        // Message handlers
        socket.on('new_message', (data) => {
            // Check if message already exists
            const existingMessage = messageContainer.querySelector(`[data-client-id="${data.client_id}"]`);
            
            if (!existingMessage) {
                addMessageToDOM(data, 'sent');
                
                // Show notification for received messages
                if (data.sender_id !== userId) {
                    showToast(`New message from ${data.sender}`, 'success');
                }
            }
        });

        socket.on('message_confirmed', (data) => {
            // Remove from pending and update status
            if (pendingMessages.has(data.client_id)) {
                const element = messageContainer.querySelector(`[data-client-id="${data.client_id}"]`);
                if (element) {
                    updateMessageStatus(element, 'sent', data);
                }
                pendingMessages.delete(data.client_id);
            }
        });

        socket.on('message_failed', (data) => {
            // Update message status to failed
            if (data.client_id) {
                const element = messageContainer.querySelector(`[data-client-id="${data.client_id}"]`);
                if (element) {
                    updateMessageStatus(element, 'failed');
                    
                    // Add retry functionality
                    element.addEventListener('click', () => {
                        retryMessage(data.client_id, element);
                    });
                }
                pendingMessages.delete(data.client_id);
            }
            
            showToast(data.error || 'Failed to send message', 'error');
            if (sendBtn) sendBtn.disabled = false;
        });

        socket.on('error', (data) => {
            showToast(data.message || 'An error occurred', 'error');
            if (sendBtn) sendBtn.disabled = false;
        });

        socket.on('status_update', (data) => {
            console.log('Status update:', data.message);
            if (data.last_sequence !== undefined) {
                currentSequence = Math.max(currentSequence, data.last_sequence);
            }
        });

        // Retry failed message
        function retryMessage(clientId, element) {
            const content = element.querySelector('.message-content').textContent;
            const newClientId = generateClientId();
            
            // Update element with new client ID
            element.dataset.clientId = newClientId;
            updateMessageStatus(element, 'sending');
            
            // Send with new client ID
            socket.emit('send_message', {
                application_id: applicationId,
                content: content,
                client_id: newClientId
            });
            
            pendingMessages.set(newClientId, {
                content: content,
                timestamp: new Date()
            });
        }

        // Send message with Socket.IO
        const messageForm = document.getElementById('message-form');
        if (messageForm) {
            messageForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                if (!messageInput || !sendBtn) return;
                
                const content = messageInput.value.trim();
                if (!content) return;

                // Validate message length
                if (content.length > 1000) {
                    showToast('Message too long (max 1000 characters)', 'error');
                    return;
                }

                // Generate client ID
                const clientId = generateClientId();
                
                // Show optimistic UI immediately
                const messageData = {
                    client_id: clientId,
                    sender: '{{ current_user.first_name }}',
                    sender_id: userId,
                    content: content,
                    timestamp: new Date().toLocaleString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    }),
                    sequence_number: currentSequence + 1
                };
                
                addMessageToDOM(messageData, 'sending');
                
                // Clear input immediately
                messageInput.value = '';
                const charCount = document.getElementById('charCount');
                if (charCount) charCount.textContent = '0';
                
                // Disable send button temporarily
                sendBtn.disabled = true;
                
                if (socket && socket.connected) {
                    // Send via Socket.IO
                    socket.emit('send_message', {
                        application_id: applicationId,
                        content: content,
                        client_id: clientId
                    });
                    
                    // Track pending message
                    pendingMessages.set(clientId, {
                        content: content,
                        timestamp: new Date()
                    });
                    
                    // Re-enable button after short delay
                    setTimeout(() => {
                        if (sendBtn) sendBtn.disabled = false;
                    }, 1000);
                } else {
                    // Fallback to HTTP with client ID in hidden field
                    const hiddenInput = document.createElement('input');
                    hiddenInput.type = 'hidden';
                    hiddenInput.name = 'client_id';
                    hiddenInput.value = clientId;
                    messageForm.appendChild(hiddenInput);
                    
                    // Also add content back for form submission
                    messageInput.value = content;
                    
                    showToast('Sending via fallback method...', 'success');
                    messageForm.submit();
                }
            });
        }

        // Quick reply buttons
        document.querySelectorAll('.quick-reply-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const replies = {
                    "approved": "Your application has been approved! Please contact us to arrange pickup.",
                    "questions": "We need more information about your home environment before proceeding.",
                    "rejected": "We need more details about your living situation before we can approve this application."
                };
                
                if (messageInput && replies[btn.dataset.reply]) {
                    messageInput.value = replies[btn.dataset.reply];
                    messageInput.focus();
                    
                    // Update character counter
                    const charCount = document.getElementById('charCount');
                    if (charCount) {
                        charCount.textContent = messageInput.value.length;
                    }
                }
            });
        });

    } catch (e) {
        console.log("Socket.IO initialization failed:", e);
        showToast("Using fallback messaging mode", "error");
        updateConnectionStatus(false);
        usePolling = true;
    }
}

// Initialize socket connection
initializeSocket();

// Cleanup pending messages older than 30 seconds
setInterval(() => {
    const now = new Date();
    for (const [clientId, messageInfo] of pendingMessages.entries()) {
        if (now - messageInfo.timestamp > 30000) {
            const element = messageContainer.querySelector(`[data-client-id="${clientId}"]`);
            if (element) {
                updateMessageStatus(element, 'failed');
            }
            pendingMessages.delete(clientId);
        }
    }
}, 10000);
</script>

<!-- Keyboard shortcuts -->
<script>
document.addEventListener('keydown', function(e) {
    const messageInput = document.querySelector('input[name="message"]');
    
    // Ctrl/Cmd + Enter to send message
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && messageInput && messageInput.value.trim()) {
        e.preventDefault();
        const form = document.getElementById('message-form');
        if (form) {
            const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
            form.dispatchEvent(submitEvent);
        }
    }
    
    // Escape to clear input
    if (e.key === 'Escape' && messageInput) {
        messageInput.value = '';
        const charCount = document.getElementById('charCount');
        if (charCount) charCount.textContent = '0';
    }
});

// Prevent accidental page refresh
window.addEventListener('beforeunload', function(e) {
    if (pendingMessages.size > 0) {
        e.preventDefault();
        e.returnValue = 'You have messages being sent. Are you sure you want to leave?';
        return e.returnValue;
    }
});
</script>
{% endblock %}